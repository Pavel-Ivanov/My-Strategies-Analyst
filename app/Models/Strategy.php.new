<?php

namespace App\Models;

use App\Enums\StrategyStatus;
use App\Enums\TransactionType;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Strategy extends Model
{
    protected $fillable = [
        'status',
        'name',
        'description',
        'strategy_url',
        'resource_id',
        'chain_id',
        'wallet_id',
        'wallet_address',
        'start_at',
        'finish_at',
        'limit_price_min',
        'limit_price_max',
    ];

    protected $casts = [
        'status' => StrategyStatus::class,
        'start_at' => 'datetime',
        'finish_at' => 'datetime',
        'initial_deposit' => 'decimal:8',
    ];

    // Relationships
    public function resource(): BelongsTo
    {
        return $this->belongsTo(Resource::class);
    }

    public function chain(): BelongsTo
    {
        return $this->belongsTo(Chain::class);
    }

    public function wallet(): BelongsTo
    {
        return $this->belongsTo(Wallet::class);
    }

    public function assets(): BelongsToMany
    {
        return $this->belongsToMany(Asset::class, 'asset_strategy', 'strategy_id', 'asset_id')
            ->orderBy('order');
    }

    public function strategyAssets(): HasMany
    {
        return $this->hasMany(AssetStrategy::class);
    }

    /**
     * The parameters that belong to the strategy.
     */
    public function parameters(): BelongsToMany
    {
        return $this->belongsToMany(StrategyParameter::class, 'strategy_strategy_parameter')
            ->using(StrategyStrategyParameter::class)
            ->withPivot('value')
            ->withTimestamps();
    }

    /**
     * Get the strategy parameter relationships.
     */
    public function strategyParameters(): HasMany
    {
        return $this->hasMany(StrategyStrategyParameter::class);
    }


    // Mutators
    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeFinished($query)
    {
        return $query->whereNotNull('finish_at');
    }

    // Custom Methods
    public function isActive(): bool
    {
        return $this->status === 'active';
    }

    public function duration()
    {
        if ($this->finish_at) {
            return (int) $this->start_at->diffInDays($this->finish_at);
        }
        return (int) $this->start_at->diffInDays(now());
    }

    public function transactions(): HasMany
    {
        return $this->hasMany(Transaction::class);
    }

    public function transactionsByType(?TransactionType $type = null)
    {
        $query = $this->hasMany(Transaction::class);

        if ($type !== null) {
            $query->where('transaction_type', $type);
        }
        return $query;
    }

    public function getTransactionsAmountAtDate(TransactionType $type, ?Carbon $date = null)
    {
        $query = $this->transactionsByType($type);

        if ($date !== null) {
            $query->where('created_at', '<=', $date);
        }
        return $query->sum('total_value');
    }

    public function snapshots(): HasMany
    {
        return $this->hasMany(Snapshot::class);
    }

    /**
     * Получает последний снимок стратегии.
     *
     * @return Snapshot|null Возвращает последний снимок или null, если снимков нет
     */
    public function getLatestSnapshot(): ?Snapshot
    {
        if (!$this->hasSnapshots()) {
            return null;
        }

        return $this->snapshots()->latest()->first();
    }

    /**
     * Проверяет, есть ли у стратегии снимки.
     *
     * @return bool
     */
    public function hasSnapshots(): bool
    {
        return $this->snapshots()->exists();
    }

     /**
     * Возвращает общую стоимость стратегии на указанную дату.
     * Включает ликвидность, неполученные комиссии из последнего снимка до указанной даты
     * и сумму всех собранных комиссий до указанной даты.
     *
     * @param Carbon|null $date Дата, на которую нужно получить стоимость. Если null, используется текущая дата
     * @return float
     */
    public function getTotalValue(?Carbon $date = null): float
    {
        $snapshotValue = 0;

        if ($date) {
            $snapshot = $this->snapshots()
                ->where('created_at', '<=', $date)
                ->latest()
                ->first();
        } else {
            $snapshot = $this->getLatestSnapshot();
        }
//        dump($snapshot);
        if ($snapshot) {
            $snapshotValue = $snapshot->total_liquidity + $snapshot->fees_uncollected;
        }

//        $collectedFees = $this->getTransactionsAmountAtDate(TransactionType::COLLECT_FEES, $date);

//        return $snapshotValue + $collectedFees;
        return $snapshotValue;
    }

}
